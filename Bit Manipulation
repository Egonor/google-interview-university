Bit Manipulation

Bitwise Operators:
AND 		&
OR			|
XOR 		^	(Exclusive OR)
NOT 		~
LEFT SHIFT	<<
RIGHT SHIFT >>

AND: Only true if both input bits are true.
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
1 & 1 = 1

OR:	True if any input bit is true.
0 | 0 = 0
1 | 0 = 1
0 | 1 = 1
1 | 1 = 1

XOR: True if and only if one input bit is true. (Essentialy checks to see if the input bits are different.)
0 ^ 0 = 0
1 ^ 0 = 1
0 ^ 1 = 1
1 ^ 1 = 0

NOT: Ones' complement operator.  Flips the input bit.
~0 = 1
~1 = 0

LEFT SHIFT: Shift the binary digits by n, pad 0's on the right.  
			Each shift is essentialy a multiply by 2 
				* Unless there's overflow, in which case the bits are thrown away.
				* Processors can ROTATE to wrap the bits around (but it still isn't a multiply by 2)
00010110 (22)
<<
00000010 (2)	(Shift left by 2... 22 * 2 * 2)
01011000 (88)	(22 * 2 = 44 * 2 = 88)

RIGHT SHIFT: Shift the binary digits by n, pad 0's on the left
			 Each shift is essentially a divide by 2 with round towards negative infinity.

00010110 (22)
>>
00000010 (2)	(Shift right by 2... 22 / 2 / 2)
00000101 (5)	(22 / 2 = 11, 11/2 = 5.5, roundDown(5.5) = 5)


_____Bit Manipulation Basics_____ (Bit masks) 
0b00000110 (0b prefix for binary in python) | bin() function returns binary as a string 

***SET BIT***
def set_bit(x, position):		(Set a 0 bit, in a desired position, to 1)
	mask = 1 << position		(Define the mask (00000001) then shift it to the desired position (00100000))
	return x | mask				(OR the mask with the bit to insure that it's 1)

x			00000110
position	00000101 (5...Target the 5th bit)
mask	 	00100000
result		00100110

***CLEAR BIT***
def clear_bit(x, position):
	mask = 1 << position
	return x & ~mask			()

x			00000110		
position	00000010 (index 2)
mask		00000100 
~mask		11111011 (1. Flip the mask)
result		00000010 (2. x AND ~mask, returns 1s from x minus the clear bit.)

***FLIP BIT***
def flip_bit(x, position):
	mask = 1 << position
	return x ^ mask

***IS BIT SET***
Shift the desired bit to index 0, then AND it with 1.  If the (shifted) rightmost bit is 1, it will return true when ANDed with 1.
def is_bit_set(x, position):
	shifted = x >> position
	return shifted & 1

x = 01100110	position = 00000101 (index 5)
shifted		00000011 (by 5)
		  & 00000001 (1)
		  = 00000001 (True)

***MODIFY BIT*** state = 0 (clear bit), state = 1 (set bit)
def modify_bit(x, position, state):
	mask = 1 << position
	return (x & ~mask) | (-state & mask)


_____Bit Tricks_____
Check if Even: (x & 1) == 0 or ~(x & 1)...(!(x & 1))?
  0110
& 0001
  0000

Check if Pow2: (x & x-1) == 0
 * A power of 2 should only have ONE bit set.
 * If power of 2, subtracting 1 will set 1 bit to 0 and all bits right of it to 1.
  1000 (8)
& 0111 (7)
  0000



// Write a function to count the number of bits that are different between two numbers
def different(numA, numB):
	count = 0
	mask = numA ^ numB
	foreach bit in mask: //pseudocode, forgot how to python loop
		if is_bit_set(mask, bit):
			count++
	return count